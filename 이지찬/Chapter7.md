# Chapter 07 - 애그리게이트와 일관성 경계

## 일관성 경계
* **ACID의 Atomic**
    * **데이터 상태가 항상 일관되게 유지 되어야 함**
    * **예를 들어 계좌 이체시 내 계좌에서 돈을 출금하는 작업과 다른 계좌에 입금하는 작업이 둘다 성공하거나 한쪽이 실패 할 경우 모두 실패**

## 7.2 불변조건, 제약, 일과ㄴ성
* **제약**
    * **어떤 상태값에 대한 제한**
    * **예를 들어 재고의 값은 0 이하로 설정 할 수 없다**
* **불변조건**
    * **항상 참이여야 하는 조건**
    * **예를 들어 상품 주문시 지불해야 하는 가격은 상품 가격 X 주문한 수량 이라는 규칙이 있으면 어떤 상품을 주문하든 몇개를 주문하던 이 규칙은 지켜져야하는 조건**

## 7.2.1 불변조건, 동시성, 락
* **만약 불변조건이 재고가 0이하인 상품은 주문할수 없다라는 규칙이 있다고 가정**
* **동시성 이라는 상황이 발생 했을 경우 재고가 1개밖에 남지 않았을때 주문이 동시에 들어오면 음수가 되어 버리는 상황이 발생 할 수 있다.**
* **이때 락이라는 기술을 적용 함으로써 재고값의 변경이라는 작업은 하나씩밖에 처리 하지 못하게 막아버리면 이런 문제를 막을 수 있다.**
* **다만 이 숫자가 커져버리면 교착 상태가 발생하여 성능에 큰 문제가 발새ㅇ 할 수가 있다.**
* **왜냐하면 동시에 특정 데이터에 대해 여러가지 작업이 실행 되었을때 먼저 시작된 작업이 하나씩 처리되고 또 그 작업이 끝나기 전까지는 해당 데이터를 가지고 추가로 작업 처리를 하지 못하며 그 외 작업은 해당 작업이 끝날때까지 기다려야 하기 때문이다. **
    
## 7.3 애그리게이트란?
* **작업단위(트랜잭션 단위)에서 일관성을 유지 해야하는 행위와 데이터의 경계**
* **예를 들어 책을 주문하는 상황이었을때를 가정 해보자**
* **여러가지 애그리게이트를 정의 할 수 있으며 주문, 재고변경, 결제 등에 대한 각각의 애그리게이트가 있다.**
* **재고변경의 경우 주문이 발생했을때 주문한 수량만큼 재고가 감소 해야하는 작업단위가 있다.**
* **주문한 수량이 1이고 남아있는 재고가 1일 경우 1개가 차감되어 0으로 반영 되야 하며**
* **주문한 수량이 2이고 남아있는 재고가 1일 경우 음수가 되기 때문에 주문이 되어서는 안된다.**
* **즉, 주문한 수량보다 재고가 많으면 주문이 성공해야하고 재고가 적으면 주문이 실패해야 한다.**
* **결제의 경우 책의 가격만큼 결제를 해야하는 작업 단위가 있다.**
* **책의 가격만큼 주문자의 계좌에서 송금 판매자의 계좌에 책의가격이 입금되야 한다.**
* **잔액이 충분히 있어서 송금에 성공하고 판매자의 계좌에 해당 금액이 입금되었을 경우 주문이 성공**
* **잔액이 없어서 송금에 실패 했을경우 주문에 실패**
* **잔액이 충분히 있어서 송금에 성공하고 판매자의 계좌에 입금이 되지 않았을 경우 주문이 실패**
* **애그리게이트는 어떤 작업(행위)을 함에 있어 내부적으로 반드시 지켜져야하는 불변조건(규칙)의 집합**
* **이 조건을 지켰으면 성공 이 조건을 지키지 못했으면 실패**
* **이를 하나의 트랜잭션으로 묶어서 처리**
* **애그리게이트와 트랜잭션이 비슷해 보일수 있음**
    * **애그리게이트는 데이터의 일관성을 유지하기 위한 논리적인 수단**
    * **트랜잭션은 데이터의 일관성을 유지하기 위환 기술적인 수단**

### 데이터 일관성을 유지하기 위한 다양한 방법
* **기술적 수단**
    1. 트랜잭션
        * **작업을 모두 성공하거나 모두 실패처리**
    2. 낙관적/비관적 동시성 제어
        * **낙관적: 버전 번호를 통해 충돌을 감지하여 하나는 성공 하나는 실패처리**
        * **비관적: 락을 통해 동시에 접근하지 못하도록 처리**
    3. 분산 트랜잭션
        * **여러 데이터베이스에 걸친 트랜잭션을 관리 (2PC, 3PC) / XA 프로토콜, JTA ?**
            * **XA 프로토콜: 2단계 커밋이라는 과정, 두개의 DB에 대해서 커밋이 가능한지에 대한 통신처리후 커밋 처리**
            * **JTA: XA프로토콜을 자바에서 사용 할 수 있게 해주는 API**
    4. CDC(Change Data Capture)
        * **로그기반으로 데이터 일관성유지**
* **논리적 수단**
    1. 애그리게이트 패턴
        * **관련 Entity들을 경계로 묶어서 처리**
    2. 이벤트 소싱
        * **상태변경을 이벤트로 저장 및 처리한다.**
    3. CQRS
        * **조회와 수정 처리를 분리**
    4. 사가패턴
        * **긴 트랜잭션을 작은 지역 트랜잭션으로 나눔**
        * **주로 마이크로 서비스에서 사용됨**
        * **주문 -> 결제 -> 배송 의 흐름일 경우 결제 실패시 주문도 취소된다.**
    5. 최종적 일관성
        * **즉시 일관성을 보장하지는 않지만 시간이 지나면 일관된 상태에 도달**
    6. 불변 데이터
        * **데이터를 수정하지 않고 새로운 데이터를 생성**
        * **충돌없이 일관성 유지가 가능하다.**



## 7.5 한 애그리게이트=한 저장소
* **풀어서 보면 하나의 저장소 -> 하나의 repository 사용**
* **주문(Order) 테이블과 관계가 있는 즉, 조인이 가능한 테이블들과의 상호작용을 할 수 있기 때문에**
* **주문 식별자를 통해 데이터를 가져오고 주문 식별자를 가지고만 생성, 수정, 삭제처리를 해야한다.**

## 7.8.2 비관적 동시성 제어 예제: select for update
* **낙관적 동시성 제어의 경우 동시에 접근 할 수 있어 성능상 이점이 있으나 명시적 실패처리를 해주어야 하고 재시도에 대한 보완 로직이 추가적으로 필요하다**
* **비관적 동시성 제어의 경우 동시에 접근 할 수 없으며 한쪽이 처리되는 동안 기다려야 하는 성능상 단점이 있지만 충돌로 인한 실패처리 로직이 필요하지는 않다.**